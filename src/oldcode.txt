float time1 = std::clock();
      cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGRA8);
      Mat imageInRGB;
      cvtColor(cv_ptr->image,imageInRGB,COLOR_RGBA2RGB);

      //PREPROCESSING STEP
      Mat resolutionReduced;
      cv::resize(imageInRGB,resolutionReduced,Size(desiredX,desiredY));
      //DATA FORMAT FOR INPUT TO NETWORK
      std::vector<torch::jit::IValue> inputs;
      torch::Tensor tensor_image = torch::from_blob(resolutionReduced.data, {1,resolutionReduced.rows, resolutionReduced.cols, resolutionReduced.channels() }, at::kByte).to(device).toType(c10::kFloat);
      tensor_image = tensor_image.permute({ 0,3,1,2 });
      inputs.push_back(tensor_image);
      float time2 = std::clock();
      //PREDICTION FROM SEMANTIC SEGMENTATION NETWORK
      at::Tensor output = semanticSegmentationModule.forward(inputs).toTensor().argmax(1);